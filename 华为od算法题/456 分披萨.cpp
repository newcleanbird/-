///*
//456、分披萨
//题目描述：
//“吃货”和“馋嘴”两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数扇形小块。但是粗心服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。
//由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从“吃货”开始，轮流取披萨。除了第一块披萨可以任意选取以外，其他都必须从缺口开始选。
//他俩选披萨的思路不同。“馋嘴”每次都会选最大块的披萨，而且“吃货”知道“馋嘴”的想法。
//已知披萨小块的数量以及每块的大小，求“吃货”能分得的最大的披萨大小的总和。
//
//输入描述：
//第1行为一个正整数奇数N，表示披萨小块数量。3 <= N < 500。
//接下来的第2行到第N+1行（共N行），每行为一个正整数，表示第i块披萨的大小。1 <= i <= N。披萨小块从某一块开始，按照一个方向依次顺序编号为1~N。每块披萨的大小范围为[1, 2147483647]。
//
//输出描述：
//“吃货”能分得的最大的披萨大小的总和。
//
//示例1
//输入：
//5
//8
//2
//10
//5
//7
//输出：
//19
//说明：
//
//此例子中，有5块披萨。每块大小依次为8、2、10、5、7。按照如下顺序拿披萨，可以使“吃货”拿到最多披萨：
//1、“吃货”拿大小为10的披萨
//2、“馋嘴”拿大小为5的披萨
//3、“吃货”拿大小为7的披萨
//4、“馋嘴”拿大小为8的披萨
//5、“吃货”拿大小为2的披萨
//至此，披萨瓜分完毕，“吃货”拿到的披萨总大小为10+7+2=19。
//可能存在多种拿法，以上只是其中一种。
//
//思路：dp记忆化搜索+递归
//1. 起始点任意选择，因此需要枚举每一种起始点
//2. 每次馋嘴只有唯一选择，即选择当前最大的
//3. 每次吃货有两个选择，选择左边或右边，然后记录结果。
//*/
//
//#include <iostream>
//#include <vector>
//
//using namespace std;
//
//long n;  // 披萨的数量
//vector<int> pizza;  // 每块披萨的美味值
//vector<vector<long>> dp;  // 记忆化数组，用于存储已计算过的状态
//
//long solve(int L, int R) {
//    /* 馋嘴选择 */
//    if (pizza[L] > pizza[R]) {
//        L = (L + n - 1) % n;
//    }
//    else {
//        R = (R + n + 1) % n;
//    }
//
//    /* 吃货选择 */
//    // 如果该状态已经计算过，则直接返回结果
//    if (dp[L][R] != -1) {
//        return dp[L][R];
//    }
//    // 如果左右端点相同，则说明只剩下一块披萨，直接返回该披萨的美味值
//    if (L == R) {
//        dp[L][R] = pizza[L];
//    }
//    else {
//        // 分别计算选择左边披萨和选择右边披萨的情况下的最大美味值
//        dp[L][R] = max(pizza[L] + solve((L + n - 1) % n, R), pizza[R] + solve(L, (R + n + 1) % n));
//    }
//    return dp[L][R];
//}
//
//int main() {
//    // 输入
//    cin >> n;  // 输入披萨的数量
//    pizza.resize(n);  // 调整披萨美味值数组的大小为n
//    dp.assign(n, vector<long>(n, -1));  // 初始化记忆化数组dp，全部赋值为-1
//    for (int i = 0; i < n; i++) {
//        cin >> pizza[i];  // 输入每块披萨的美味值
//    }
//
//    // 开始搜索
//    long ans = 0;
//    // 枚举吃货第一步取哪块披萨
//    for (int i = 0; i < n; i++) {
//        // 计算当前情况下吃货最多能吃到的披萨的美味值，并更新答案
//        ans = max(ans, solve((i + n - 1) % n, (i + n + 1) % n) + pizza[i]);
//    }
//    cout << ans << endl;  // 输出最多能吃到的披萨的美味值
//    return 0;
//}