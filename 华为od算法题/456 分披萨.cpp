/*
456、分披萨
题目描述：
“吃货”和“馋嘴”两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数扇形小块。但是粗心服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。
由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从“吃货”开始，轮流取披萨。除了第一块披萨可以任意选取以外，其他都必须从缺口开始选。
他俩选披萨的思路不同。“馋嘴”每次都会选最大块的披萨，而且“吃货”知道“馋嘴”的想法。
已知披萨小块的数量以及每块的大小，求“吃货”能分得的最大的披萨大小的总和。

输入描述：
第1行为一个正整数奇数N，表示披萨小块数量。3 <= N < 500。
接下来的第2行到第N+1行（共N行），每行为一个正整数，表示第i块披萨的大小。1 <= i <= N。披萨小块从某一块开始，按照一个方向依次顺序编号为1~N。每块披萨的大小范围为[1, 2147483647]。

输出描述：
“吃货”能分得的最大的披萨大小的总和。

示例1
输入：
5
8
2
10
5
7
输出：
19
说明：

此例子中，有5块披萨。每块大小依次为8、2、10、5、7。按照如下顺序拿披萨，可以使“吃货”拿到最多披萨：
1、“吃货”拿大小为10的披萨
2、“馋嘴”拿大小为5的披萨
3、“吃货”拿大小为7的披萨
4、“馋嘴”拿大小为8的披萨
5、“吃货”拿大小为2的披萨
至此，披萨瓜分完毕，“吃货”拿到的披萨总大小为10+7+2=19。
可能存在多种拿法，以上只是其中一种。

思路：dp记忆化搜索+递归
1. 起始点任意选择，因此需要枚举每一种起始点
2. 每次馋嘴只有唯一选择，即选择当前最大的
3. 每次吃货有两个选择，选择左边或右边，然后记录结果。
*/

#include <iostream>
#include <vector>

using namespace std;

long n;  // 披萨的数量
vector<int> pizza;  // 每块披萨的美味值
vector<vector<long>> dp;  // 记忆化数组，用于存储已计算过的状态

long solve(int L, int R) {
    /* 馋嘴选择 */
    if (pizza[L] > pizza[R]) {
        L = (L + n - 1) % n;
    }
    else {
        R = (R + n + 1) % n;
    }

    /* 吃货选择 */
    // 如果该状态已经计算过，则直接返回结果
    if (dp[L][R] != -1) {
        return dp[L][R];
    }
    // 如果左右端点相同，则说明只剩下一块披萨，直接返回该披萨的美味值
    if (L == R) {
        dp[L][R] = pizza[L];
    }
    else {
        // 分别计算选择左边披萨和选择右边披萨的情况下的最大美味值
        dp[L][R] = max(pizza[L] + solve((L + n - 1) % n, R), pizza[R] + solve(L, (R + n + 1) % n));
    }
    return dp[L][R];
}

int main() {
    // 输入
    cin >> n;  // 输入披萨的数量
    pizza.resize(n);  // 调整披萨美味值数组的大小为n
    dp.assign(n, vector<long>(n, -1));  // 初始化记忆化数组dp，全部赋值为-1
    for (int i = 0; i < n; i++) {
        cin >> pizza[i];  // 输入每块披萨的美味值
    }

    // 开始搜索
    long ans = 0;
    // 枚举吃货第一步取哪块披萨
    for (int i = 0; i < n; i++) {
        // 计算当前情况下吃货最多能吃到的披萨的美味值，并更新答案
        ans = max(ans, solve((i + n - 1) % n, (i + n + 1) % n) + pizza[i]);
    }
    cout << ans << endl;  // 输出最多能吃到的披萨的美味值
    return 0;
}