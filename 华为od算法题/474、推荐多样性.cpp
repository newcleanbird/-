/*
474、推荐多样性
题目描述：
推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据（窗口数量），每屏展示K个元素（窗口大小），选择策略：
1. 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推
2. 每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，参考样例图：
（1）从第一个列表中选择4条0 1 2 3，分别放到4个窗口中
（2）从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
（3）从第三个列表中选择4条20 21 22 23，分别放到4个窗口中
（4）再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
...
（5）再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗口1和窗口2
（6）再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗口要求，取18 19放到窗口3和窗口4

输入描述：
第一行输入为N，表示需要输出的窗口数量，取值范围 [1, 10]
第二行输入为K，表示每个窗口需要的元素数量，取值范围 [1, 100]
之后的行数不定（行数取值范围[1,10]），表示每个列表输出的元素列表。元素之间以空格分隔，已经过排序处理，每个列表输出的元素数量取值范围[1,100]

输出描述：
输出元素列表，元素数量=窗口数量*窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：
先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
补充说明：
1. 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况
2. 每个列表的元素已去重，不需要考虑元素重复情况
3. 每个列表的元素列表均不为空，不需要考虑列表为空情况
4. 每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
5. 每个列表的元素数量可能是不同的

示例1
输入：
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出：
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
说明：
*/

#include<iostream>
#include<vector>
#include<sstream>
#include<queue>

using namespace std;

int main()
{
	int n, k; // N，表示需要输出的窗口数量			K，表示每个窗口需要的元素数量
	cin >> n >> k;
	cin.get();
	vector<vector<int>> vec;
	string str;
	while (getline(cin, str))
	{
		istringstream iss(str);
		string token;
		vector<int> vec_tmp;
		while (getline(iss, token, ' '))
		{
			vec_tmp.push_back(stoi(token));
		}
		vec.push_back(vec_tmp);
	}
	int n_l = vec.size(); // 列表的数量

	// 开始添加
	vector<vector<int>> res(n);	// n个窗口

	int pos = 0; // 当前查询的列表号
	int times = 0;	// 某个列表中已遍历的次数
	vector<int> ids(n_l, 0); // 用于记录每个列表中当前查询的序号
	for (int i = 0; i < k; i++)	// 一共需要添加k次元素，循环k次，每次循环对应填充每个窗口的一轮元素
	{
		for (int j = 0; j < n; j++)	// 循环n次，对应各个窗口
		{
			if (ids[pos] >= vec[pos].size())// 当前遍历的列表已越界
			{
				pos = (pos + 1) % n_l;
				times = 0;
			}
			int cur = vec[pos][ids[pos]];	// 当前待添加的数据
			res[j].push_back(cur);
			ids[pos]++;

			// 更新列表当前已遍历的数量
			times++;
			if (times >= n)
			{
				pos = (pos + 1) % n_l;
				times = 0;
			}
		}
	}

	// 输出
	for (auto i : res)
	{
		for (auto j : i)
		{
			cout << j << " ";
		}
	}

}