///*
//474、推荐多样性
//题目描述：
//推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据（窗口数量），每屏展示K个元素（窗口大小），选择策略：
//1. 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推
//2. 每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，参考样例图：
//（1）从第一个列表中选择4条0 1 2 3，分别放到4个窗口中
//（2）从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
//（3）从第三个列表中选择4条20 21 22 23，分别放到4个窗口中
//（4）再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
//...
//（5）再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗口1和窗口2
//（6）再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗口要求，取18 19放到窗口3和窗口4
//
//输入描述：
//第一行输入为N，表示需要输出的窗口数量，取值范围 [1, 10]
//第二行输入为K，表示每个窗口需要的元素数量，取值范围 [1, 100]
//之后的行数不定（行数取值范围[1,10]），表示每个列表输出的元素列表。元素之间以空格分隔，已经过排序处理，每个列表输出的元素数量取值范围[1,100]
//
//输出描述：
//输出元素列表，元素数量=窗口数量*窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：
//先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
//补充说明：
//1. 每个列表会保证元素数量满足窗口要求，不需要考虑元素不足情况
//2. 每个列表的元素已去重，不需要考虑元素重复情况
//3. 每个列表的元素列表均不为空，不需要考虑列表为空情况
//4. 每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
//5. 每个列表的元素数量可能是不同的
//
//示例1
//输入：
//4
//7
//0 1 2 3 4 5 6 7 8 9
//10 11 12 13 14 15 16 17 18 19
//20 21 22 23 24 25 26 27 28 29
//输出：
//0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
//说明：
//*/
//
//#include<iostream>
//#include<vector>
//#include<sstream>
//#include<queue>
//
//using namespace std;
//
//int main()
//{
//	int n, k; // N，表示需要输出的窗口数量			K，表示每个窗口需要的元素数量
//	cin >> n >> k;
//	cin.get();
//	vector<vector<int>> vec;
//	string str;
//	while (getline(cin, str))
//	{
//		istringstream iss(str);
//		string token;
//		vector<int> vec_tmp;
//		while (getline(iss, token, ' '))
//		{
//			vec_tmp.push_back(stoi(token));
//		}
//		vec.push_back(vec_tmp);
//	}
//	int n_l = vec.size(); // 列表的数量
//
//	// 开始添加
//	vector<vector<int>> res(n);	// n个窗口
//
//	int pos = 0; // 当前查询的列表号
//	int times = 0;	// 某个列表中已遍历的次数
//	vector<int> ids(n_l, 0); // 用于记录每个列表中当前查询的序号
//	for (int i = 0; i < k; i++)	// 一共需要添加k次元素，循环k次，每次循环对应填充每个窗口的一轮元素
//	{
//		for (int j = 0; j < n; j++)	// 循环n次，对应各个窗口
//		{
//			if (ids[pos] >= vec[pos].size())// 当前遍历的列表已越界
//			{
//				pos = (pos + 1) % n_l;
//				times = 0;
//			}
//			int cur = vec[pos][ids[pos]];	// 当前待添加的数据
//			res[j].push_back(cur);
//			ids[pos]++;
//
//			// 更新列表当前已遍历的数量
//			times++;
//			if (times >= n)
//			{
//				pos = (pos + 1) % n_l;
//				times = 0;
//			}
//		}
//	}
//
//	// 输出
//	for (auto i : res)
//	{
//		for (auto j : i)
//		{
//			cout << j << " ";
//		}
//	}
//
//}