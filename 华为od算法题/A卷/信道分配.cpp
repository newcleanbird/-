/*
https://blog.csdn.net/qq_34465338/article/details/125317576?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167957887816800197053804%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167957887816800197053804&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-125317576-null-null.142^v76^control_1,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E4%BF%A1%E9%81%93%E5%88%86%E9%85%8D%20%E5%8D%8E%E4%B8%BAod&spm=1018.2226.3001.4187
标题：信道分配 | 时间限制：1秒 | 内存限制：262144K | 语言限制：不限
算法工程师小明面对着这样一个问题，需要将通信用的信道分配给尽量多的用户：

信道的条件及分配规则如下：
1)     所有信道都有属性：”阶”。阶为r的信道的容量为2^r比特；
2)     所有用户需要传输的数据量都一样：D比特；
3)     一个用户可以分配多个信道，但每个信道只能分配给一个用户；
4)     只有当分配给一个用户的所有信道的容量和>=D，用户才能传输数据；
给出一组信道资源，最多可以为多少用户传输数据？

输入描述
第一行，一个数字R。R为最大阶数。
0<=R<20

第二行，R+1个数字，用空格隔开。
代表每种信道的数量Ni。按照阶的值从小到大排列。
0<=i<=R, 0<=Ni<1000.

第三行，一个数字D。
D为单个用户需要传输的数据量。
0<D<1000000

输出描述:

一个数字，代表最多可以供多少用户传输数据。

示例1
输入
5
10 5 0 1 3 2
30

输出
4

说明

最大阶数为5.
信道阶数：0       1    2    3    4    5
信道容量：1       2    4    8    16  32  
信道个数：10     5    0    1    3    2
单个用户需要传输的数据量为30
可能存在很多分配方式，举例说明：

分配方式1：
1)     32*1 = 32
2)     32*1 = 32
3)     16*2 = 32
4)     16*1 + 8*1 + 2*3 = 30

剩下2*2 + 1*10=14不足以再分一个用户了。

分配方式2：
1)     16*1 + 8*1 + 2*3 = 30
2)     16*1 + 2*2 + 1*10 = 30
3)     32*1 = 32
4)     32*1 = 32

剩下16*1=16不足以再分一个用户了。

分配方式3：
1)     16*1 + 8*1 + 2*3 = 30
2)     16*1 + 2*2 + 1*10 = 30
3)     16*1 + 32*1 = 48
4)     32*1 = 32

恰好用完。
虽然每种分配方式剩下的容量不同，但服务的用户数量是一致的。因为这个问题中我们只关心服务的用户数，所以我们认为这些分配方式等效。

*/

#include<bits/stdc++.h>

using namespace std;

vector<int> result;

void back_tracking(vector<int> &num, )
{

}


int main()
{
    int R; //R为最大阶数
    cin >> R;
    // 第二行，R+1个数字，用空格隔开。
    vector<int> num(R); // 代表每种信道的数量Ni。按照阶的值从小到大排列。
    for(int i = 0; i < R; i++)
    {
        cin >> num[i];
    }
    int D;  // 第三行，一个数字D。
    for(int i = 0; i < R; i++)
    {

    }

}