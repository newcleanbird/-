/*
419 执行任务赚积分 / 积分奖励
题目描述：
现有N个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。
每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。
输入描述：
第一行为一个数N，表示有N个任务，1<=N<=100
第二行为一个数T，表示可用于处理任务的时间。1<=T<=100
接下来N行，每行两个空格分隔的整数(SLA和V)，SLA表示任务的最晚处理时间，V表  示任务对应的积分。1<=SLA<=100, 0<=V<=100000

输出描述：可获得的最多积分

示例1
输入：
4
3
1 2
1 3
1 4
1 5
输出：5
说明：
虽然有3个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。
所以在第1个时间单位内，选择处理有 5 个积分的任务。1-3 时无任务处理。

示例2
输入：
4
3
1 2
1 3
1 4
3 5
输出：9
说明：
第1个时间单位内，处理任务3，获得4个积分
第2个时间单位内，处理任务4，获得5个积分
第3个时间单位内，无任务可处理
共获得9个积分

思路：
	在有限的时间内，赚取最大的积分。

思路2：
我们可以把任务按照时间从小到大的顺序排序，维护一个小根堆表示我们最终要去处理的这些任务
	由于每次处理任务需要耗时1，因此最多只能处理 T 个任务，小根堆中元素的数量不能大于 T。
	当遍历到第 i 个事件，首先我们需要去比较第 i 个事件的过期时间 t 是否比小根堆中的元素数量要大，如果大的话，判断小根堆是否满，如果没满，就可以直接加入到小根堆中，如果满了，则需要跟小根堆堆顶元素比较大小，如果比堆顶元素大，则可以将堆顶元素弹出，将当前元素添加到小根堆中
	如果发现第 i 个事件的过期时间 t 是否比小根堆中的元素数量要小（就是出现了样例1中有多个事件在同一时间截止，但是最多只能处理一个的情况），则需要跟小根堆堆顶元素比较大小，如果比堆顶元素大，则可以将堆顶元素弹出，将当前元素添加到小根堆中
			如何保证当前弹出的元素的位置就符合当前添加的元素呢？
			因为先按顺序将所有的数据进行了排序，因此当前数据之前的数据至少都比当前的数据更早到期。因此加入一个晚到期的数据一定能够替换早到期的数据。
假如 2
1 1
1 3
1 5
1 6
2 2
2 4

1 5
1 6
*/

#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>

using namespace std;

int main()
{
	// 输入
	int n;	// N个任务
	int t;	// 可用于处理任务的时间
	cin >> n >> t;
	vector<pair<int, int>> v;	// SLA表示任务的最晚处理时间，V表示任务对应的积分
	for (int i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		v.push_back({ a, b });
	}
	sort(v.begin(), v.end());	// 按照处理事件先后顺序从小到大排序
	priority_queue<int, vector<int>, greater<int>> heap;  // 定义小根堆	维护的小根堆大小不能超过t
	for (int i = 0; i < n; i++)	// 遍历所有任务
	{
		if (v[i].first > heap.size())	// 当前任务的时间期限比当前的堆大。也就是说不管堆后续如何变化，当前任务肯定会被执行。
		{
			if (heap.size() < t)	// 堆未满，可以直接加入
			{
				heap.push(v[i].second);
			}
			else if(v[i].second > heap.top()){	// 堆满了，如果当前任务价值比堆顶大
				heap.pop();
				heap.push(v[i].second);
			}
		}
		else {	// 任务过期咯
			if (v[i].second > heap.top())
			{
				heap.pop();
				heap.push(v[i].second);
			}
		}
	}
	int count = 0;
	while (!heap.empty())
	{
		count += heap.top();
		heap.pop();
	}
	cout << count;

}